# Anotações

. Validação Matemática do CPF (Custom Annotation)
O que é e Por que Fazer?
Validação Regex (Sintaxe): A sua validação atual (@Pattern(regexp = "\\d{11}")) verifica apenas se o campo cpf tem exatamente 11 dígitos.

Exemplo: Um usuário pode digitar 11111111111 ou 12345678901. Ambos passam na sua regex.

Validação Matemática (Semântica): O CPF no Brasil tem dois dígitos de controle, chamados Dígitos Verificadores (DVs), que são calculados com base nos 9 primeiros dígitos.

Se você cadastrar um CPF inválido, como 111.111.111-11, ele é um CPF "válido" pela sua regex, mas é matematicamente inválido e, portanto, nunca existirá na Receita Federal.

A validação matemática calcula os DVs esperados e verifica se eles batem com os DVs informados pelo usuário. Isso evita a inserção de dados inúteis/falsos no seu sistema.

Como Resolver (A Abordagem Sênior)
A melhor forma de implementar isso no Spring Boot é usando uma Custom Annotation com Bean Validation:

Crie a Annotation: @CPFValido (ou similar) que você aplicaria diretamente no campo cpf do seu DTO:

Java

public class ClienteCreateDTO {
    // ... outros campos
    @CPFValido // <-- Nova Anotação
    private String cpf;
    // ...
}
Crie o Validador: Uma classe (CPFValidator) que implementa a interface ConstraintValidator e contém a lógica (o algoritmo) para calcular e checar os dígitos verificadores do CPF. O Spring/Jakarta fará o resto, chamando essa lógica automaticamente.

Benefício Sênior: Se amanhã você precisar validar CPF em outro DTO (ex: um DTO de Vendedor), basta colocar a anotação @CPFValido e a regra se aplica, garantindo reutilização e DRY (Don't Repeat Yourself).

2. Normalização de Dados de Telefone
O que é e Por que Fazer?
O Problema (Regex Rígida): Sua regex atual para telefone é ótima para garantir um formato específico ((XX) XXXXX-XXXX).

Exemplo: Aceita (11) 98765-4321.

Mas falha em: 11987654321 (sem máscara) ou (11) 987654321 (sem o traço).

Isso força o usuário a formatar o telefone exatamente como você definiu, o que pode ser uma fricção desnecessária.

A Normalização (Usabilidade e Consistência):

Usabilidade: É mais user-friendly aceitar o telefone em formatos comuns (com ou sem a máscara).

Consistência no Banco de Dados: Para evitar inconsistências e facilitar buscas futuras, o telefone deve ser armazenado no banco de dados em um formato padronizado (o formato "limpo", apenas dígitos).

Como Resolver (A Abordagem Sênior)
A normalização deve ocorrer na camada de Serviço ou, idealmente, usando um Custom Editor ou função de pré-processamento:

No DTO (ClienteCreateDTO):

Relaxe a validação @Pattern para aceitar um formato mais amplo (o formato formatado ou o formato somente dígitos).

No Serviço (ClienteService):

Antes de mapear o DTO para a Entidade, você "limpa" o dado:

public ClienteResponseDTO cadastrarCliente(ClienteCreateDTO dto) {
    // 1. Lógica de Negócio: Checar unicidade do CPF

    // 2. Normalização (Limpar a string)
    String telefoneLimpo = dto.getTelefone().replaceAll("[^\\d]", ""); // Remove tudo que não for dígito

    // 3. Mapeamento para a Entidade
    Cliente cliente = new Cliente();
    // ... setar outros campos

    cliente.setTelefone(telefoneLimpo); // Salva o telefone LIMPO
    // ...
}
Benefício Sênior: Você entrega um Front-end mais amigável (aceita vários formatos) e um banco de dados limpo e padronizado (só salva dígitos), que é ideal para integrações e buscas.